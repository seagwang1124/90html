<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통큰통독-01일차</title>
    <link rel="apple-touch-icon" type="image/png" href="https://i.postimg.cc/Qtnq0gFJ/Ezra-icon.png">
    <meta name="apple-mobile-web-app-title" content="통큰통독">
    <link rel="shortcut icon" type="image/png" href="https://i.postimg.cc/Qtnq0gFJ/Ezra-icon.png">
    <link rel="mask-icon" type="image/png" href="https://i.postimg.cc/Qtnq0gFJ/Ezra-icon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }

        /* 검색 하이라이트 스타일 */
        .search-highlight {
            background-color: #fde047;
            color: #1f2937;
            border-radius: 4px;
            padding: 2px 4px;
        }

        /* 스크롤 마커 컨테이너 */
        .scroll-marker-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 8px;
            height: 100vh;
            z-index: 99;
            pointer-events: none;
        }

        /* 스크롤 마커 */
        .scroll-marker {
            position: absolute;
            right: 0;
            width: 8px;
            height: 8px;
            background-color: #ef4444;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s ease;
        }

        .scroll-marker:hover {
            transform: scale(1.5);
        }

        /* 로딩 스피너 */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 구절 설명 버튼 애니메이션 */
        .explanation-button-wrapper {
            transition: all 0.3s ease-in-out;
        }

        .explanation-sub-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px) scale(0.8);
            transition: all 0.3s ease-in-out;
        }

        .explanation-icon-button {
            opacity: 1;
            visibility: visible;
            transition: all 0.3s ease-in-out;
        }

        /* 'show' 클래스가 있을 때의 스타일 */
        .explanation-button-wrapper.show .explanation-sub-buttons {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }
        
        .explanation-button-wrapper.show .explanation-icon-button {
            opacity: 0;
            visibility: hidden;
            pointer-events: none; /* 하위 버튼 클릭을 방해하지 않도록 함 */
        }

        /* 모달 애니메이션 */
        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }
        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: all 0.3s ease;
        }
        .modal-leave-active {
            transition: all 0.3s ease;
        }
        .modal-leave-to {
            opacity: 0;
            transform: scale(0.95);
        }
        
        /* 모달 이미지 스타일 */
        .modal-image-container {
            position: relative;
            width: 100%;
            padding-bottom: 75%; /* 4:3 비율 유지 */
            overflow: hidden;
            border-radius: 0.5rem; /* rounded-lg */
            margin-bottom: 1rem; /* mb-4 */
        }

        .modal-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* 이미지가 잘리지 않고 전체 보이도록 수정 */
            object-position: center;
        }

        /* 모달 텍스트 스타일 */
        .modal-text-container {
            max-height: 80vh;
            overflow-y: auto;
            padding-bottom: 1rem;
        }

        .modal-title {
            font-weight: bold;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            position: sticky;
            top: 0;
            background-color: white;
            padding-bottom: 0.5rem;
            z-index: 10;
        }
        
        /* 새로운 CSS: 줄 간격을 글자 높이와 비슷하게 좁게 만듭니다. */
        .leading-extra-tight {
            line-height: 1.1;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <!-- 상단 고정 헤더 -->
    <div class="fixed top-0 left-0 w-full bg-white bg-opacity-95 backdrop-blur-sm shadow-md p-4 z-50">
        <div class="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0">
            <!-- 검색 폼 -->
            <div class="w-full md:w-1/3">
                <form id="search-form" class="flex items-center space-x-2 w-full">
                    <button type="button" id="reset-btn" class="p-2 bg-gray-200 rounded-full text-sm font-bold w-8 h-8 flex items-center justify-center">X</button>
                    <input type="text" id="search-input" placeholder="검색어를 입력하세요" class="flex-grow p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button type="submit" class="p-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">검색</button>
                </form>
                <div id="search-count-container" class="flex items-center mt-2 pl-12 text-sm text-gray-600">
                    <span id="search-count" class="font-semibold"></span>
                    <button type="button" id="next-location-btn" class="ml-2 px-3 py-1 bg-gray-200 text-gray-800 rounded-md text-xs font-medium hover:bg-gray-300 transition-colors hidden">다음 위치</button>
                </div>
            </div>

            <!-- 오디오 플레이어 -->
            <div class="w-full md:w-2/3 flex flex-col items-center justify-center">
                <audio id="audio-file" preload="auto">
                    <source src="https://vod47.anyline.co.kr/vod_ezra/%EC%9D%BD%EA%B8%B0%2001.mp3" type="audio/mp3">
                </audio>
                <div class="player-controls flex items-center justify-center gap-2 mb-2">
                    <span id="current-time" class="text-sm font-mono text-gray-500">0:00</span>
                    <button id="play-btn" class="p-2 bg-green-200 rounded-full hover:bg-green-300 transition-colors shadow-md">▶</button>
                    <button id="pause-btn" class="p-2 bg-yellow-200 rounded-full hover:bg-yellow-300 transition-colors shadow-md">⏸</button>
                    <button id="stop-btn" class="p-2 bg-red-200 rounded-full hover:bg-red-300 transition-colors shadow-md">■</button>
                    <span id="remaining-time" class="text-sm font-mono text-gray-500">0:00</span>
                </div>
                <div class="speed-volume-controls flex items-center justify-center gap-4">
                    <div class="speed-controls flex items-center gap-1">
                        <button id="speed-down-02" class="px-2 py-1 text-sm bg-gray-200 rounded-md hover:bg-gray-300 transition-colors">&lt;&lt;</button>
                        <button id="speed-down-01" class="px-2 py-1 text-sm bg-gray-200 rounded-md hover:bg-gray-300 transition-colors">&lt;</button>
                        <span id="speed-display" class="text-blue-600 font-bold text-sm w-12 text-center">1.0x</span>
                        <button id="speed-up-01" class="px-2 py-1 text-sm bg-gray-200 rounded-md hover:bg-gray-300 transition-colors">&gt;</button>
                        <button id="speed-up-02" class="px-2 py-1 text-sm bg-gray-200 rounded-md hover:bg-gray-300 transition-colors">&gt;&gt;</button>
                    </div>
                    <div class="volume-control flex items-center gap-1">
                        <span class="text-xs text-gray-500">볼륨</span>
                        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1" class="w-24">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 본문 내용 컨테이너 -->
    <div class="relative max-w-3xl mx-auto px-4 mt-[250px] pb-32">
        <!-- 구절 설명 버튼 컨테이너 -->
        <div class="explanation-button-container fixed top-[120px] md:top-[140px] left-1/2 -translate-x-1/2 z-40 w-full flex justify-center p-2 box-border">
            <div class="explanation-button-wrapper relative flex items-center justify-center">
                <!-- 책 모양 아이콘 버튼 -->
                <button class="explanation-icon-button absolute w-12 h-12 md:w-14 md:h-14 bg-pink-300 rounded-full shadow-md flex items-center justify-center text-4xl cursor-pointer" id="explanation-icon-button">
                    <span>📖</span>
                </button>
                <!-- 하위 버튼들: '전체 간단'과 '전체 상세' 버튼 추가 -->
                <div class="explanation-sub-buttons absolute top-0 left-1/2 -translate-x-1/2">
                    <button class="explanation-sub-button bg-pink-300 text-gray-800 text-xs md:text-sm px-3 py-2 rounded-md shadow-md hover:scale-105 transition-transform" id="full-simple-explanation-button">전체본문 간단</button>
                    <button class="explanation-sub-button bg-pink-300 text-gray-800 text-xs md:text-sm px-3 py-2 rounded-md shadow-md hover:scale-105 transition-transform" id="full-detailed-explanation-button">전체본문 상세</button>
                    <button class="explanation-sub-button bg-pink-300 text-gray-800 text-xs md:text-sm px-3 py-2 rounded-md shadow-md hover:scale-105 transition-transform" id="detailed-explanation-button">선택문장 상세</button>
                    <button class="explanation-sub-button bg-pink-300 text-gray-800 text-xs md:text-sm px-3 py-2 rounded-md shadow-md hover:scale-105 transition-transform" id="simple-explanation-button">선택문장 간단</button> <!-- 라벨 수정 -->
                    <button class="explanation-sub-button bg-pink-300 text-gray-800 text-xs md:text-sm px-3 py-2 rounded-md shadow-md hover:scale-105 transition-transform" id="image-explanation-button">선택문장 그림</button>
                </div>
            </div>
        </div>

        <!-- 폰트 크기 조절 -->
        <div class="flex items-center justify-center mb-6">
            <span class="text-lg font-bold text-blue-600 mr-4">글꼴 크기</span>
            <button id="down" class="w-10 h-10 text-2xl font-normal text-red-500 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-100">-</button>
            <span id="font-size" class="text-2xl font-bold text-red-500 mx-4 w-10 text-center">20</span>
            <button id="up" class="w-10 h-10 text-2xl font-normal text-red-500 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-100">+</button>
        </div>

        <!-- 성경 본문 -->
        <div id="bible-text" class="text-xl leading-extra-tight text-left text-gray-800 word-break-keep-all whitespace-pre-line">
            <strong>

통독 1일차
<br>범위: 창세기 1장- 11장</br>
<br>&nbsp;</br>

</strong>
<strong><br><font color="#4682b4">창세기 1 장</font></br></strong>
<br><i><font color="#808080">*천지 창조*</font></i></br>
<br>1 태초에 하나님이 천지를 창조하시니라</br>
<br>2 땅이 혼돈하고 공허하며 흑암이 깊음 위에 있고 하나님의 영은 수면 위에 운행하시니라</br>
<br>3 하나님이 이르시되 빛이 있으라 하시니 빛이 있었고</br>
<br>&nbsp;</br>
<br>    1일차 끝</br>
<br>&nbsp;</br>
        </div>
    </div>

    <!-- 모달 -->
    <div id="explanation-modal" class="fixed inset-0 z-[100] bg-gray-900 bg-opacity-50 hidden flex items-center justify-center">
        <!-- 모달 컨텐츠: 높이 제한 및 스크롤 가능하게 수정 -->
        <div class="modal-content relative w-11/12 max-w-lg bg-white p-6 rounded-lg shadow-2xl text-left transition-all duration-300 modal-enter">
            <button class="absolute top-2 right-2 text-gray-700 hover:text-gray-900 text-3xl font-bold" id="close-modal">&times;</button>
            
            <!-- 모달 내용을 담을 스크롤 가능 컨테이너 -->
            <div class="modal-text-container">
                <h3 id="modal-title" class="modal-title"></h3>
                <div id="modal-image-container" class="modal-image-container hidden">
                    <img id="modal-image" src="" alt="설명 관련 이미지" class="modal-image">
                </div>
                <div id="modal-text" class="text-gray-700 leading-relaxed">구절을 드래그하여 선택하고 '구절설명' 버튼을 누르세요.</div>
            </div>
        </div>
    </div>

    <!-- 스크롤 마커 컨테이너 -->
    <div id="scroll-marker-container" class="scroll-marker-container"></div>
    
    <script>
        // ------------------------------
        // 설정: 여기에 직접 API 키를 입력하세요.
        // https://aistudio.google.com/app/apikey 에서 발급받을 수 있습니다.
        // ------------------------------
        // IMPORTANT: In the Canvas environment, the API key is automatically provided.
        // But for standalone HTML file, you must paste your own key here.
        const API_KEY = "AIzaSyDUlSQlSPgnrFBXpnUJMDoUO3s_KsaoFRU"; // <-- 여기에 본인의 API 키를 붙여넣으세요.
        // ------------------------------

        // DOM 요소
        const bibleTextEl = document.getElementById('bible-text');
        const searchInput = document.getElementById('search-input');
        const searchForm = document.getElementById('search-form');
        const searchCountEl = document.getElementById('search-count');
        const nextLocationBtn = document.getElementById('next-location-btn');
        const resetBtn = document.getElementById('reset-btn');
        const scrollMarkerContainer = document.getElementById('scroll-marker-container');
        const explanationIconButton = document.getElementById('explanation-icon-button');
        const detailedExplanationButton = document.getElementById('detailed-explanation-button');
        const simpleExplanationButton = document.getElementById('simple-explanation-button');
        const imageExplanationButton = document.getElementById('image-explanation-button');
        
        // 새로 추가된 버튼
        const fullSimpleExplanationButton = document.getElementById('full-simple-explanation-button');
        const fullDetailedExplanationButton = document.getElementById('full-detailed-explanation-button');

        const modal = document.getElementById('explanation-modal');
        const modalContent = document.querySelector('.modal-content');
        const closeModalButton = document.getElementById('close-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalImageContainer = document.getElementById('modal-image-container');
        const modalImage = document.getElementById('modal-image');
        const modalText = document.getElementById('modal-text');
        const audio = document.getElementById('audio-file');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const speedDisplay = document.getElementById('speed-display');
        const speedDown02Btn = document.getElementById('speed-down-02');
        const speedDown01Btn = document.getElementById('speed-down-01');
        const speedUp01Btn = document.getElementById('speed-up-01');
        const speedUp02Btn = document.getElementById('speed-up-02');
        const volumeSlider = document.getElementById('volume-slider');
        const currentTimeEl = document.getElementById('current-time');
        const remainingTimeEl = document.getElementById('remaining-time');
        const upBtn = document.getElementById('up');
        const downBtn = document.getElementById('down');
        const fontSizeEl = document.getElementById('font-size');
        const explanationButtonWrapper = document.querySelector('.explanation-button-wrapper');

        // 상태값
        let selectedVerse = "";
        let originalText = "";
        let foundSentences = [];
        let currentSearchIndex = -1;
        let currentSpeed = 1.0;

        // 유틸: RegExp 특수문자 이스케이프
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // 페이지 초기화
        window.addEventListener('DOMContentLoaded', () => {
            originalText = bibleTextEl.innerHTML;
            updateFontSizeDisplay();
            updateSpeed();
        
            // 텍스트 드래그/선택 이벤트
            document.addEventListener('mouseup', () => {
                const selection = window.getSelection();
                selectedVerse = selection ? selection.toString().trim() : '';
            });

            // 검색 폼
            if (searchForm) {
                searchForm.addEventListener('submit', (event) => {
                    event.preventDefault();
                    findString(searchInput.value);
                });
            }
            if (resetBtn) resetBtn.addEventListener('click', clearHighlight);
            if (nextLocationBtn) nextLocationBtn.addEventListener('click', nextLocation);
        
            // 폰트 크기 조절
            if (upBtn) upBtn.addEventListener('click', () => {
                let currentSize = parseFloat(window.getComputedStyle(bibleTextEl).fontSize);
                if (currentSize + 2 <= 40) {
                    bibleTextEl.style.fontSize = (currentSize + 2) + 'px';
                    updateFontSizeDisplay();
                }
            });
            if (downBtn) downBtn.addEventListener('click', () => {
                let currentSize = parseFloat(window.getComputedStyle(bibleTextEl).fontSize);
                if (currentSize - 2 >= 12) {
                    bibleTextEl.style.fontSize = (currentSize - 2) + 'px';
                    updateFontSizeDisplay();
                }
            });
        
            // 오디오 컨트롤
            playBtn.addEventListener('click', () => { audio.play(); });
            pauseBtn.addEventListener('click', () => { audio.pause(); });
            stopBtn.addEventListener('click', () => { audio.pause(); audio.currentTime = 0; });
        
            speedDown02Btn.addEventListener('click', () => { currentSpeed = Math.max(0.5, currentSpeed - 0.2); updateSpeed(); });
            speedDown01Btn.addEventListener('click', () => { currentSpeed = Math.max(0.5, currentSpeed - 0.1); updateSpeed(); });
            speedUp01Btn.addEventListener('click', () => { currentSpeed = Math.min(2.0, currentSpeed + 0.1); updateSpeed(); });
            speedUp02Btn.addEventListener('click', () => { currentSpeed = Math.min(2.0, currentSpeed + 0.2); updateSpeed(); });
        
            volumeSlider.addEventListener('input', () => { audio.volume = volumeSlider.value; });
        
            audio.addEventListener('timeupdate', () => {
                const currentTime = audio.currentTime;
                const duration = audio.duration;
                currentTimeEl.textContent = formatTime(currentTime);
                if (isFinite(duration)) {
                    const remainingTime = duration - currentTime;
                    remainingTimeEl.textContent = '-' + formatTime(remainingTime);
                }
            });
        
            // 아이콘 클릭 -> 서브버튼 표시/숨기기
            explanationIconButton.addEventListener('click', (event) => {
                event.stopPropagation(); // 버튼 클릭 시 body 클릭 이벤트 전파 방지
                explanationButtonWrapper.classList.add('show');
            });
        
            // 상세/간단/그림 설명 버튼 클릭 시 모달 열기
            detailedExplanationButton.addEventListener('click', (event) => {
                event.stopPropagation();
                const trimmedVerse = selectedVerse.trim();
                if (!trimmedVerse) {
                    showModal("구절을 먼저 선택하세요", "본문에서 구절이나 단어를 드래그하여 선택한 후 다시 버튼을 눌러주세요.");
                } else {
                    fetchExplanation(trimmedVerse, 'detailed');
                }
                explanationButtonWrapper.classList.remove('show');
            });
        
            simpleExplanationButton.addEventListener('click', (event) => {
                event.stopPropagation();
                const trimmedVerse = selectedVerse.trim();
                if (!trimmedVerse) {
                    showModal("구절을 먼저 선택하세요", "본문에서 구절이나 단어를 드래그하여 선택한 후 다시 버튼을 눌러주세요.");
                } else {
                    fetchExplanation(trimmedVerse, 'simple');
                }
                explanationButtonWrapper.classList.remove('show');
            });
        
            imageExplanationButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                const trimmedVerse = selectedVerse.trim();
                if (!trimmedVerse) {
                    showModal("구절을 먼저 선택하세요", "본문에서 구절이나 단어를 드래그하여 선택한 후 다시 버튼을 눌러주세요.");
                } else {
                    await fetchImageAndDescription(trimmedVerse);
                }
                explanationButtonWrapper.classList.remove('show');
            });

            // 새로 추가된 '전체 간단' 버튼 클릭 이벤트 리스너
            fullSimpleExplanationButton.addEventListener('click', (event) => {
                event.stopPropagation();
                const fullText = bibleTextEl.innerText;
                if (!fullText.trim()) {
                    showModal("본문 내용이 없습니다", "분석할 성경 본문이 없습니다.");
                } else {
                    fetchOverallExplanation(fullText, 'full_simple');
                }
                explanationButtonWrapper.classList.remove('show');
            });
            
            // 새로 추가된 '전체 상세' 버튼 클릭 이벤트 리스너
            fullDetailedExplanationButton.addEventListener('click', (event) => {
                event.stopPropagation();
                const fullText = bibleTextEl.innerText;
                if (!fullText.trim()) {
                    showModal("본문 내용이 없습니다", "분석할 성경 본문이 없습니다.");
                } else {
                    fetchOverallExplanation(fullText, 'full_detailed');
                }
                explanationButtonWrapper.classList.remove('show');
            });


            // body 외부 클릭 시 하위 버튼 닫기
            document.body.addEventListener('click', (event) => {
                if (!explanationButtonWrapper.contains(event.target)) {
                    explanationButtonWrapper.classList.remove('show');
                }
            });
        
            // 모달 닫기
            closeModalButton.addEventListener('click', hideModal);
            modal.addEventListener('click', (event) => {
                if (event.target === modal) {
                    hideModal();
                }
            });
        });

        // 폰트 크기 표시 업데이트
        function updateFontSizeDisplay() {
            const currentSize = parseFloat(window.getComputedStyle(bibleTextEl).fontSize);
            fontSizeEl.textContent = Math.round(currentSize);
        }
        
        // 재생 속도 업데이트
        function updateSpeed() {
            audio.playbackRate = currentSpeed;
            speedDisplay.textContent = currentSpeed.toFixed(1) + 'x';
        }
        
        // 시간 포맷
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // 검색 및 하이라이트
        function findString(searchText) {
            clearHighlight();
            if (!searchText || searchText.trim() === '') {
                searchCountEl.textContent = '';
                nextLocationBtn.classList.add('hidden');
                return;
            }
            const escaped = escapeRegExp(searchText);
            const regex = new RegExp(escaped, 'gi');
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalText;
            
            const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT, null, false);
            let node;
            const textNodesToReplace = [];
            while ((node = walker.nextNode())) {
                textNodesToReplace.push(node);
            }

            for (const textNode of textNodesToReplace) {
                const text = textNode.nodeValue;
                if (text.match(regex)) {
                    const parent = textNode.parentNode;
                    const newContent = text.replace(regex, (match) => `<span class="search-highlight">${match}</span>`);
                    const tempSpan = document.createElement('span');
                    tempSpan.innerHTML = newContent;
                    while (tempSpan.firstChild) {
                        parent.insertBefore(tempSpan.firstChild, textNode);
                    }
                    parent.removeChild(textNode);
                }
            }
            
            bibleTextEl.innerHTML = tempDiv.innerHTML;
            foundSentences = Array.from(bibleTextEl.getElementsByClassName('search-highlight'));
            
            searchCountEl.textContent = `총 ${foundSentences.length}개 검색됨`;
            if (foundSentences.length > 0) {
                currentSearchIndex = 0;
                foundSentences[currentSearchIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                nextLocationBtn.classList.remove('hidden');
                updateScrollMarkers();
            } else {
                showModal("검색 결과 없음", `"${searchText}"에 대한 검색 결과가 없습니다.`);
                nextLocationBtn.classList.add('hidden');
            }
        }
        
        // 다음 검색 위치
        function nextLocation() {
            if (foundSentences.length > 0) {
                currentSearchIndex = (currentSearchIndex + 1) % foundSentences.length;
                foundSentences[currentSearchIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        // 하이라이트 초기화
        function clearHighlight() {
            bibleTextEl.innerHTML = originalText;
            searchInput.value = '';
            searchCountEl.textContent = '';
            nextLocationBtn.classList.add('hidden');
            while (scrollMarkerContainer.firstChild) scrollMarkerContainer.removeChild(scrollMarkerContainer.firstChild);
            foundSentences = [];
            currentSearchIndex = -1;
        }
        
        // 스크롤 마커 업데이트
        function updateScrollMarkers() {
            while (scrollMarkerContainer.firstChild) scrollMarkerContainer.removeChild(scrollMarkerContainer.firstChild);
            const documentHeight = bibleTextEl.scrollHeight;
            const viewportHeight = window.innerHeight;
            for (let i = 0; i < foundSentences.length; i++) {
                const el = foundSentences[i];
                const marker = document.createElement('div');
                marker.className = 'scroll-marker';
                const topPosition = el.getBoundingClientRect().top + window.scrollY;
                const markerPosition = (topPosition / documentHeight) * viewportHeight;
                marker.style.top = `${markerPosition}px`;
                marker.addEventListener('click', () => {
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
                scrollMarkerContainer.appendChild(marker);
            }
        }
        
        /**
         * showModal: 모달을 열고 내용을 표시
         * @param {string} title 모달 제목
         * @param {string} text 모달 텍스트 내용
         * @param {string} [imageUrl=null] 모달 이미지 URL
         * @param {boolean} [isLoading=false] 로딩 상태 여부
         */
        function showModal(title, text, imageUrl = null, isLoading = false) {
            modalTitle.textContent = title;
            modalText.innerHTML = (text || '').toString().replace(/\n/g, '<br>');
            
            // 로딩 상태에 따라 이미지와 텍스트를 제어
            if (isLoading) {
                modalImageContainer.classList.add('hidden');
                modalText.innerHTML = `<span class="text-xl font-semibold flex items-center justify-center text-blue-500">${imageUrl ? '<span class="loader"></span> 그림 생성 중...' : '<span class="loader"></span> 설명 생성 중...'}</span>`;
            } else {
                if (imageUrl) {
                    modalImage.src = imageUrl;
                    modalImageContainer.classList.remove('hidden');
                } else {
                    modalImage.src = '';
                    modalImageContainer.classList.add('hidden');
                }
            }

            modal.classList.remove('hidden');
            modal.classList.add('flex');
            modalContent.classList.remove('modal-enter');
            modalContent.classList.add('modal-enter-active');
        }

        // 모달 닫기
        function hideModal() {
            modalContent.classList.add('modal-leave-to');
            modalContent.classList.remove('modal-enter-active');
            setTimeout(() => {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                modalContent.classList.remove('modal-leave-to');
                modalContent.classList.add('modal-enter');
            }, 300); // CSS transition time과 맞춤
        }
        
        /**
         * API 호출을 위한 재시도 로직
         * @param {Function} apiCall API를 호출하는 함수
         * @param {number} retries 남은 재시도 횟수
         * @param {number} delay 현재 지연 시간 (밀리초)
         */
        async function withRetry(apiCall, retries = 3, delay = 1000) {
            try {
                return await apiCall();
            } catch (error) {
                if (retries > 0 && error.status !== 400 && error.status !== 401 && error.status !== 403) { // 40x 에러는 재시도 하지 않음
                    console.warn(`API 호출 실패. ${delay / 1000}초 후 재시도... 남은 횟수: ${retries - 1}`);
                    await new Promise(res => setTimeout(res, delay));
                    return withRetry(apiCall, retries - 1, delay * 2);
                } else {
                    throw error;
                }
            }
        }
        
        /**
         * fetchExplanation: 상세/간단 설명 생성
         * @param {string} promptText 설명할 텍스트
         * @param {string} type 'detailed' 또는 'simple'
         */
        async function fetchExplanation(promptText, type) {
            showModal(promptText, '', null, true); // 로딩 메시지 표시

            const model = "gemini-2.5-flash-preview-05-20";
            const systemPrompt = "당신은 성경 지식에 해박한 전문가입니다. 성경에 나오는 단어나 구절에 대해 질문을 받으면, 해당 용어의 배경과 의미를 깊이 있게 설명해주세요. 한국어로 답변해 주세요.";
            let prompt;

            if (type === 'simple') {
                prompt = `다음 성경 용어/구절에 대해 300자에서 500자 사이의 짧고 간결한 설명을 한국어로 작성해 주세요. 핵심 내용을 중심으로 요약해 주세요. 요청 용어/구절: "${promptText}"`;
            } else { // detailed
                prompt = `다음 성경 용어/구절에 대해 성경적 관점에서 자세히 설명해 주세요. 답변은 최소 100자 이상으로 한국어로 작성해 주세요. 필요한 경우 표 또는 간단한 지도를 포함하거나 참조해 주세요. 요청 용어/구절: "${promptText}"`;
            }

            try {
                const result = await withRetry(async () => {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            systemInstruction: { parts: [{ text: systemPrompt }] }
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        const errorMessage = errorData.error?.message || `API 호출에 실패했습니다. (상태 코드: ${response.status})`;
                        const customError = new Error(errorMessage);
                        customError.status = response.status;
                        throw customError;
                    }

                    return response.json();
                });

                const explanation = result?.candidates?.[0]?.content?.parts?.[0]?.text || "요청하신 내용에 대한 설명을 찾을 수 없습니다.";
                showModal(promptText, explanation);
            } catch (err) {
                showModal("오류 발생", `설명을 가져오는 중 오류가 발생했습니다: ${err.message}`);
            }
        }
        
        /**
         * fetchOverallExplanation: 본문 전체를 대상으로 한 요약 생성
         * @param {string} fullText 본문 전체 텍스트
         * @param {string} type 'full_simple' 또는 'full_detailed'
         */
        async function fetchOverallExplanation(fullText, type) {
            showModal("전체 본문 분석", '', null, true); // 로딩 메시지 표시

            const model = "gemini-2.5-flash-preview-05-20";
            const systemPrompt = "당신은 성경 주석가이자 성경 연구자입니다. 사용자가 제공한 성경 본문을 학문적·신학적 배경에서 분석하여, 핵심 주제와 메시지에 집중하여 답변해주세요. 한국어로 답변해 주세요.";
            let prompt;
            
            // 공백과 줄바꿈을 제거하여 텍스트를 정제합니다.
            const cleanedText = fullText.replace(/\s+/g, ' ').trim();

            if (type === 'full_simple') {
                prompt = `성경 본문을 학문적·신학적 배경에서 분석하여, 핵심 주제와 메시지를 500자 미만으로 간단하게 요약해 주세요. 불필요한 장황한 설명은 피하고, 핵심만 요약해 주세요. 본문: "${cleanedText}"`;
            } else { // full_detailed
                prompt = `성경 본문을 학문적·신학적 배경에서 분석하여, 핵심 주제, 역사적 배경, 신학적 의미를 1000자 이상으로 자세히 설명해 주세요. 본문: "${cleanedText}"`;
            }
            
            try {
                const result = await withRetry(async () => {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            systemInstruction: { parts: [{ text: systemPrompt }] }
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        const errorMessage = errorData.error?.message || `API 호출에 실패했습니다. (상태 코드: ${response.status})`;
                        const customError = new Error(errorMessage);
                        customError.status = response.status;
                        throw customError;
                    }

                    return response.json();
                });

                const explanation = result?.candidates?.[0]?.content?.parts?.[0]?.text || "요청하신 내용에 대한 설명을 찾을 수 없습니다.";
                showModal(type === 'full_simple' ? "전체 본문 요약" : "전체 본문 심층 분석", explanation);
            } catch (err) {
                showModal("오류 발생", `설명을 가져오는 중 오류가 발생했습니다: ${err.message}`);
            }
        }
        
        /**
         * fetchImageAndDescription: 선택 구절에 대한 그림과 설명 생성
         * @param {string} promptText 설명할 텍스트
         */
        async function fetchImageAndDescription(promptText) {
            showModal(promptText, '', 'image', true); // 이미지 로딩 메시지 표시
            
            // 이미지 생성을 위한 API 호출
            const imagePrompt = `성경 구절을 묘사하는 그림을 그려주세요. 사실적으로 표현하되 예술적인 요소를 더해주세요. 구절: "${promptText}"`;
            const imageModel = "imagen-3.0-generate-002";
            const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${imageModel}:predict?key=${API_KEY}`;
            
            let imageUrl = '';
            
            try {
                const imageResult = await withRetry(async () => {
                    const imageResponse = await fetch(imageApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ instances: [{ prompt: imagePrompt }], parameters: { sampleCount: 1 } })
                    });
                    
                    if (!imageResponse.ok) {
                        const errorData = await imageResponse.json();
                        const errorMessage = errorData.error?.message || `이미지 생성 API 호출에 실패했습니다. (상태 코드: ${imageResponse.status})`;
                        const customError = new Error(errorMessage);
                        customError.status = imageResponse.status;
                        throw customError;
                    }
                    
                    return imageResponse.json();
                });
                
                const base64Data = imageResult?.predictions?.[0]?.bytesBase64Encoded;
                if (!base64Data) {
                    throw new Error("이미지 데이터가 응답에 포함되지 않았습니다.");
                }
                imageUrl = `data:image/png;base64,${base64Data}`;
                
            } catch (err) {
                showModal("오류 발생", `이미지 생성 중 오류가 발생했습니다: ${err.message}`);
                return;
            }

            // 이미지와 함께 보여줄 설명을 위한 API 호출
            const descriptionPrompt = `다음 성경 구절을 바탕으로 그림의 의미를 설명해주세요. 구절: "${promptText}"`;
            const descriptionModel = "gemini-2.5-flash-preview-05-20";
            const descriptionSystemPrompt = "당신은 성경적 그림 해설가입니다. 성경 구절을 시각적으로 묘사한 그림에 대해 깊이 있고 통찰력 있는 해설을 제공해주세요. 한국어로 답변해 주세요.";
            
            try {
                const descriptionResult = await withRetry(async () => {
                    const descriptionResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${descriptionModel}:generateContent?key=${API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: descriptionPrompt }] }],
                            systemInstruction: { parts: [{ text: descriptionSystemPrompt }] }
                        })
                    });
                    
                    if (!descriptionResponse.ok) {
                        const errorData = await descriptionResponse.json();
                        const errorMessage = errorData.error?.message || `설명 생성 API 호출에 실패했습니다. (상태 코드: ${descriptionResponse.status})`;
                        const customError = new Error(errorMessage);
                        customError.status = descriptionResponse.status;
                        throw customError;
                    }
                    
                    return descriptionResponse.json();
                });
                
                const descriptionText = descriptionResult?.candidates?.[0]?.content?.parts?.[0]?.text || "그림에 대한 설명을 찾을 수 없습니다.";
                showModal(promptText, descriptionText, imageUrl);
                
            } catch (err) {
                showModal("오류 발생", `설명 생성 중 오류가 발생했습니다: ${err.message}`, imageUrl);
            }
        }
    </script>
</body>
</html>



